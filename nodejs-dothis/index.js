// Generated by CoffeeScript 1.9.2
var moment, redis, startswith, uuid;

redis = require('redis');

uuid = require('uuid');

moment = require('moment');

startswith = function(s, prefix, position) {
  if (position == null) {
    position = 0;
  }
  return s.indexOf(prefix, position) === position;
};

module.exports = function(url, queue) {
  var pendinglist, queries, resultschannel, subscriptions, taskcallbacks, taskprefix;
  resultschannel = queue + ":results";
  pendinglist = queue + ":pending";
  taskprefix = queue + ":task:";
  taskcallbacks = {};
  queries = redis.createClient({
    url: url
  });
  subscriptions = redis.createClient({
    url: url
  });
  subscriptions.on('message', function(channel, message) {
    var taskid;
    if (channel !== resultschannel) {
      return;
    }
    if (!startswith(message, '')) {
      return;
    }
    taskid = message.substr(taskprefix.length);
    if (taskcallbacks[taskid] == null) {
      return;
    }
    return queries.hgetall("" + taskprefix + taskid, function(err, task) {
      var cb, f, i, j, k, l, len, len1, len2, len3, ref, ref1, ref2, ref3, ref4, results, results1;
      if (task.state !== 'finished') {
        return;
      }
      ref = ['args', 'result-value'];
      for (i = 0, len = ref.length; i < len; i++) {
        f = ref[i];
        if (task[f] == null) {
          continue;
        }
        task[f] = JSON.parse(task[f]);
      }
      ref1 = ['executing-created', 'finished-created'];
      for (j = 0, len1 = ref1.length; j < len1; j++) {
        f = ref1[j];
        if (task[f] == null) {
          continue;
        }
        task[f] = moment.utc(task[f], 'YYYY-MM-DD[T]HH:mm:ss.SSSSSS[Z]').toDate();
      }
      if (task.result === 'successful') {
        ref2 = taskcallbacks[taskid];
        results = [];
        for (k = 0, len2 = ref2.length; k < len2; k++) {
          cb = ref2[k];
          results.push(cb(null, task['result-value'], task));
        }
        return results;
      } else if (task.result === 'failed') {
        ref3 = taskcallbacks[taskid];
        results1 = [];
        for (l = 0, len3 = ref3.length; l < len3; l++) {
          cb = ref3[l];
          results1.push(cb((ref4 = task['error-exception']) != null ? ref4 : task, null, task));
        }
        return results1;
      }
    });
  });
  subscriptions.subscribe(resultschannel);
  return {
    task: function(name, args, cb) {
      var task, taskid;
      taskid = uuid.v4();
      if (taskcallbacks[taskid] == null) {
        taskcallbacks[taskid] = [];
      }
      taskcallbacks[taskid].push(cb);
      task = {
        "function": name,
        state: 'pending',
        args: JSON.stringify(args, null, 2)
      };
      return queries.hmset("" + taskprefix + taskid, task, function(err) {
        if (err != null) {
          return cb(err);
        }
        return queries.lpush(pendinglist, taskid, function(err) {
          if (err != null) {
            return cb(err);
          }
        });
      });
    },
    quit: function() {
      queries.quit();
      return subscriptions.quit();
    },
    end: function() {
      queries.end();
      return subscriptions.end();
    }
  };
};
